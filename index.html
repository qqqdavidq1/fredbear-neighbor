<!DOCTYPE html>
<html>
<head>
    <title>Hello Neighbor: Shotgun Update</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial Black', sans-serif; user-select: none; }
        
        #hud {
            position: absolute; top: 15px; left: 15px;
            color: #00ff00; background: rgba(0,0,0,0.8); padding: 15px; 
            border: 2px solid #00ff00; border-radius: 8px;
            font-size: 16px; min-width: 200px;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: rgba(255, 255, 255, 0.9); border: 2px solid black; border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; transition: all 0.1s;
        }
        
        /* Hit Marker Effect */
        #hit-marker {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid red; border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0; pointer-events: none;
            transition: transform 0.1s, opacity 0.1s;
        }
        .hit { transform: translate(-50%, -50%) scale(1.5) !important; opacity: 1 !important; }

        #msg-area {
            position: absolute; top: 25%; width: 100%; text-align: center;
            font-size: 36px; color: white; text-shadow: 0px 0px 10px black;
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }

        #controls {
            position: absolute; bottom: 10px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.6); font-size: 12px; font-family: sans-serif;
        }
        
        .warn { color: yellow; } .danger { color: red; } .safe { color: lime; }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="hit-marker"></div>
    <div id="msg-area"></div>
    
    <div id="hud">
        AI: <span id="ai-status" class="safe">PATROL</span><br>
        <hr style="border-color:#444">
        <div id="inv">
            Rocks: 0<br>
            Shed Key: [ ]<br>
            Crowbar: [ ]<br>
            House Key: [ ]<br>
            Shotgun: [ ]
        </div>
    </div>

    <div id="controls">
        WASD: Move | SHIFT: Run | E: Interact | LEFT CLICK: Shoot | RIGHT CLICK: Aim
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.126.0/build/three.module.js';

        // --- AUDIO SYSTEM (Procedural Sound) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playShotSound() {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            
            // Boom sound
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            gain.gain.setValueAtTime(1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
            
            osc.start(); osc.stop(audioCtx.currentTime + 0.5);

            // White noise burst
            const bufferSize = audioCtx.sampleRate * 0.1; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            noise.buffer = buffer;
            noise.connect(noiseGain); noiseGain.connect(audioCtx.destination);
            noiseGain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
            noise.start();
        }

        // --- GLOBALS ---
        const walls = []; const glass = []; const rocks = [];
        let rockCount = 0;
        let hasShedKey=false, shedOpen=false, hasCrowbar=false, hasHouseKey=false, planksGone=false, hasGun=false;
        
        // Gun State
        let lastShot = 0;
        let isAiming = false;
        let recoil = 0;

        // UI
        const msgEl = document.getElementById('msg-area');
        let msgT;
        function notify(txt, color="white") {
            msgEl.innerText = txt; msgEl.style.color = color; msgEl.style.opacity = 1;
            clearTimeout(msgT); msgT = setTimeout(()=>msgEl.style.opacity=0, 2000);
            updateInv();
        }
        function updateInv() {
            document.getElementById('inv').innerHTML = `
                Rocks: ${rockCount}<br>
                Shed Key: ${hasShedKey?"<b style='color:cyan'>[X]</b>":"[ ]"}<br>
                Crowbar: ${hasCrowbar?"<b style='color:red'>[X]</b>":"[ ]"}<br>
                House Key: ${hasHouseKey?"<b style='color:gold'>[X]</b>":"[ ]"}<br>
                Shotgun: ${hasGun?"<b style='color:orange'>[EQUIPPED]</b>":"[ ]"}
            `;
        }

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 300);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 160); camera.rotation.y = Math.PI;

        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.6));
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(50, 200, 100); sun.castShadow = true;
        scene.add(sun);

        // --- MATERIALS ---
        const mats = {
            wall: new THREE.MeshStandardMaterial({color: 0xFF8C00}),
            glass: new THREE.MeshStandardMaterial({color: 0x88ccff, opacity: 0.3, transparent: true}),
            floor: new THREE.MeshStandardMaterial({color: 0x5d4037}),
            roof: new THREE.MeshStandardMaterial({color: 0x3e2723}),
            grass: new THREE.MeshStandardMaterial({color: 0x2e7d32}),
            wood: new THREE.MeshStandardMaterial({color: 0x8d6e63}),
            steel: new THREE.MeshStandardMaterial({color: 0x778899, metalness: 0.6, roughness: 0.2})
        };

        // --- BUILDER ---
        function addWall(w,h,d,x,y,z,ry=0) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mats.wall);
            m.position.set(x,y,z); m.rotation.y=ry;
            m.castShadow=true; m.receiveShadow=true;
            scene.add(m); walls.push(m);
        }
        function addWin(w,h,d,x,y,z,ry=0) {
            const g = new THREE.Group();
            // Frame
            const sW=(w-20)/2, tH=(h-15)/2;
            const parts = [
                {w:sW,h:h,x:-(w/2)+(sW/2),y:0}, {w:sW,h:h,x:(w/2)-(sW/2),y:0},
                {w:20,h:tH,x:0,y:-(h/2)+(tH/2)}, {w:20,h:tH,x:0,y:(h/2)-(tH/2)}
            ];
            parts.forEach(p=>{
                const m=new THREE.Mesh(new THREE.BoxGeometry(p.w,p.h,d),mats.wall);
                m.position.set(p.x,p.y,0); g.add(m); walls.push(m);
            });
            // Glass
            const gl = new THREE.Mesh(new THREE.PlaneGeometry(19,14), mats.glass);
            gl.userData={broken:false};
            g.add(gl); glass.push(gl);
            g.position.set(x,y,z); g.rotation.y=ry; scene.add(g);
        }

        // --- WORLD ---
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(2000,2000), mats.grass);
        ground.rotation.x=-Math.PI/2; scene.add(ground);
        const road = new THREE.Mesh(new THREE.PlaneGeometry(2000,150), new THREE.MeshStandardMaterial({color:0x333333}));
        road.rotation.x=-Math.PI/2; road.position.set(0,0.1,150); scene.add(road);

        // House
        const f1=new THREE.Mesh(new THREE.BoxGeometry(60,1,60),mats.floor); f1.position.set(0,0.2,0); scene.add(f1);
        addWall(20,30,2, -20,15,30); addWall(20,30,2, 20,15,30); // Front
        addWall(20,30,2, -20,15,-30); addWall(20,30,2, 20,15,-30); // Back
        addWin(60,30,2, -30,15,0, Math.PI/2); // Left Win
        addWin(60,30,2, 30,15,0, Math.PI/2); // Right Win
        
        const f2=new THREE.Mesh(new THREE.BoxGeometry(60,1,60),mats.floor); f2.position.set(-60,0.2,0); scene.add(f2);
        addWin(60,30,2, -60,15,30); // Front Win
        addWall(60,30,2, -60,15,-30); addWall(2,30,60, -90,15,0);

        const f3=new THREE.Mesh(new THREE.BoxGeometry(60,1,60),mats.floor); f3.position.set(60,0.2,0); scene.add(f3);
        addWin(60,30,2, 60,15,30); // Front Win
        addWall(60,30,2, 60,15,-30); addWall(2,30,60, 90,15,0);

        const roof=new THREE.Mesh(new THREE.ConeGeometry(120,40,4),mats.roof);
        roof.position.set(0,45,0); roof.rotation.y=Math.PI/4; scene.add(roof);

        // Shed
        const sG=new THREE.Group();
        const sL=new THREE.Mesh(new THREE.BoxGeometry(2,20,20),mats.wood); sL.position.set(-10,10,0);
        const sR=new THREE.Mesh(new THREE.BoxGeometry(2,20,20),mats.wood); sR.position.set(10,10,0);
        const sB=new THREE.Mesh(new THREE.BoxGeometry(20,20,2),mats.wood); sB.position.set(0,10,-10);
        const sRf=new THREE.Mesh(new THREE.BoxGeometry(24,2,24),mats.wood); sRf.position.set(0,20,0);
        const sDr=new THREE.Mesh(new THREE.BoxGeometry(18,18,1),new THREE.MeshStandardMaterial({color:0x3e2723}));
        sDr.position.set(0,9,10);
        sG.add(sL,sR,sB,sRf,sDr); sG.position.set(80,0,-80); scene.add(sG); walls.push(sL,sR,sB,sDr);

        // Items
        const sKey=new THREE.Mesh(new THREE.BoxGeometry(1,1,3), new THREE.MeshBasicMaterial({color:0x00ffff}));
        sKey.position.set(70,1,-70); sKey.add(new THREE.PointLight(0x00ffff, 1, 10)); scene.add(sKey);

        const crow=new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,8), new THREE.MeshStandardMaterial({color:0xff0000}));
        crow.rotation.z=Math.PI/2; crow.position.set(80,5,-80); scene.add(crow);

        const hKey=new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({color:0xffd700}));
        hKey.position.set(60,5,0); scene.add(hKey); // Living room

        // --- THE SHOTGUN MODEL (Procedural) ---
        const gunPickup = new THREE.Group();
        // Barrels
        const b1 = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,12), mats.steel); b1.rotation.x=Math.PI/2; b1.position.set(-0.9,0,6);
        const b2 = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.8,12), mats.steel); b2.rotation.x=Math.PI/2; b2.position.set(0.9,0,6);
        // Stock
        const st = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 10), new THREE.MeshStandardMaterial({color: 0x8B4513})); st.position.set(0,-1,-4);
        // Handle
        const hnd = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4, 3), new THREE.MeshStandardMaterial({color: 0x8B4513})); 
        hnd.position.set(0,-2.5,-1); hnd.rotation.x=0.5;
        
        gunPickup.add(b1,b2,st,hnd);
        gunPickup.position.set(85, 4, -85); // Inside Shed
        scene.add(gunPickup);

        // First Person Gun (Attached to camera)
        const fpsGun = gunPickup.clone();
        const muzzleFlash = new THREE.PointLight(0xffff00, 0, 20);
        muzzleFlash.position.set(0, 0, 13);
        fpsGun.add(muzzleFlash);
        camera.add(fpsGun);
        fpsGun.visible = false; // Hidden until picked up

        // --- NEIGHBOR AI ---
        const neighbor = new THREE.Group();
        const legG = new THREE.BoxGeometry(1.5,5,1.5);
        const lLeg = new THREE.Mesh(legG, new THREE.MeshStandardMaterial({color:0x228822})); lLeg.position.set(-1,2.5,0);
        const rLeg = new THREE.Mesh(legG, new THREE.MeshStandardMaterial({color:0x228822})); rLeg.position.set(1,2.5,0);
        const torso = new THREE.Mesh(new THREE.BoxGeometry(4,6,2.5), new THREE.MeshStandardMaterial({color:0xffaa00})); torso.position.set(0,8,0);
        const head = new THREE.Mesh(new THREE.BoxGeometry(3,3,3), new THREE.MeshStandardMaterial({color:0xffccaa})); head.position.set(0,12.5,0);
        const stache = new THREE.Mesh(new THREE.BoxGeometry(2,0.5,0.5), new THREE.MeshBasicMaterial({color:0x000000})); stache.position.set(0,11.5,1.6);
        neighbor.add(lLeg,rLeg,torso,head,stache);
        scene.add(neighbor);

        let aiState = "PATROL";
        const waypoints = [ new THREE.Vector3(0,0,0), new THREE.Vector3(-60,0,0), new THREE.Vector3(60,0,0), new THREE.Vector3(0,0,50) ];
        let wpIdx=0;
        let stunTimer=0;

        // --- INPUTS ---
        const keys={w:false,a:false,s:false,d:false,shift:false};
        document.addEventListener('keydown',e=>{
            keys[e.key.toLowerCase()] = true;
            if(e.key==="Shift") keys.shift=true;
            if(e.code==="KeyE") interact();
        });
        document.addEventListener('keyup',e=>{
            keys[e.key.toLowerCase()] = false;
            if(e.key==="Shift") keys.shift=false;
        });
        document.addEventListener('mousedown', e=>{
            if(!document.pointerLockElement) document.body.requestPointerLock();
            if(e.button===0 && hasGun) fireGun();
            if(e.button===2 && hasGun) isAiming = true;
        });
        document.addEventListener('mouseup', e=>{
            if(e.button===2) isAiming = false;
        });
        document.addEventListener('mousemove', e=>{
            if(document.pointerLockElement) {
                camera.rotation.y -= e.movementX*0.002;
                camera.rotation.x -= e.movementY*0.002;
                camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
            }
        });

        // --- INTERACTION ---
        function interact() {
            const p = camera.position;
            // Rocks
            const r = new THREE.Mesh(new THREE.DodecahedronGeometry(1), new THREE.MeshStandardMaterial({color:0x888888}));
            r.position.set((Math.random()-0.5)*100, 1, 50+Math.random()*50);
            if(Math.random()>0.5) scene.add(r); // Spawn random rocks logic simplified for logic

            // Keys
            if(!hasShedKey && p.distanceTo(sKey.position)<10) {
                hasShedKey=true; scene.remove(sKey); notify("Got Shed Key", "cyan"); return;
            }
            if(!hasHouseKey && p.distanceTo(hKey.position)<10) {
                hasHouseKey=true; scene.remove(hKey); notify("Got House Key", "gold"); return;
            }
            if(!hasCrowbar && p.distanceTo(crow.position)<10) {
                hasCrowbar=true; scene.remove(crow); notify("Got Crowbar", "red"); return;
            }
            // Gun Pickup
            if(!hasGun && p.distanceTo(gunPickup.position)<12) {
                hasGun=true; scene.remove(gunPickup);
                fpsGun.visible = true;
                notify("SHOTGUN EQUIPPED!", "orange");
                return;
            }
            // Doors
            if(p.distanceTo(sDr.getWorldPosition(new THREE.Vector3()))<12) {
                if(hasShedKey && !shedOpen) { shedOpen=true; sDr.rotation.y=-Math.PI/2; sDr.position.x=-9; notify("Shed Opened"); }
                else if(!shedOpen) notify("Locked (Need Key)", "red");
            }
        }

        // --- SHOOTING ---
        function fireGun() {
            const now = performance.now();
            if(now - lastShot < 250) return; // 0.25s cooldown
            lastShot = now;

            playShotSound();
            recoil = 0.5; // Kick back
            
            // Flash
            muzzleFlash.intensity = 5;
            setTimeout(()=>muzzleFlash.intensity=0, 50);

            // Raycast
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(0,0), camera);

            // Check Neighbor Hit
            const hitsNeighbor = ray.intersectObject(torso, true); // Check torso hitbox roughly
            // Actually checking group bounding box is hard, let's check distance + angle manually or use ray on children
            const nHits = ray.intersectObjects(neighbor.children);
            
            if(nHits.length > 0 && nHits[0].distance < 100) {
                knockDownNeighbor();
                hitMarker();
                return; // Stop ray
            }

            // Check Glass
            const gHits = ray.intersectObjects(glass);
            if(gHits.length > 0 && gHits[0].distance < 100) {
                const g = gHits[0].object;
                if(!g.userData.broken) {
                    g.userData.broken = true; g.visible = false;
                    playShotSound(); // Extra crash noise sim
                    notify("Window Shattered!");
                    
                    // Alert AI
                    if(aiState !== "STUNNED") {
                        aiState = "CHASE"; 
                        neighbor.lookAt(camera.position.x, 0, camera.position.z);
                    }
                }
            }
        }

        function hitMarker() {
            const el = document.getElementById('hit-marker');
            el.classList.add('hit');
            setTimeout(()=>el.classList.remove('hit'), 100);
        }

        function knockDownNeighbor() {
            if(aiState === "STUNNED") return;
            aiState = "STUNNED";
            notify("NEIGHBOR STUNNED!", "red");
            stunTimer = 4.0; // Seconds
            
            // Physical knockback
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            neighbor.position.addScaledVector(dir, 10);
            neighbor.position.y = 2; // Slight hop
            
            // Rotate to lay down
            neighbor.rotation.x = -Math.PI/2; 
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            const dt = 0.016; // Approx delta

            // Player Move
            const spd = keys.shift ? 1.2 : 0.6;
            const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y=0; dir.normalize();
            const right = new THREE.Vector3(-dir.z, 0, dir.x);
            const move = new THREE.Vector3();
            if(keys.w) move.add(dir); if(keys.s) move.sub(dir);
            if(keys.a) move.sub(right); if(keys.d) move.add(right);
            camera.position.addScaledVector(move.normalize(), spd);
            
            // Wall Collision (Basic)
            if(camera.position.y < 2) camera.position.y = 10; // Floor clamp

            // Gun Animation
            if(hasGun) {
                // ADS Logic
                const targetPos = isAiming ? new THREE.Vector3(0, -1.5, -4) : new THREE.Vector3(2.5, -3, -6);
                fpsGun.position.lerp(targetPos, 0.2);
                
                // Recoil Recovery
                if(recoil > 0) {
                    fpsGun.position.z += recoil;
                    fpsGun.rotation.x += recoil * 0.5;
                    recoil -= 0.1;
                } else {
                    fpsGun.rotation.x = 0;
                }
            }

            // AI Logic
            const uiAi = document.getElementById('ai-status');
            
            if(aiState === "STUNNED") {
                uiAi.innerText = "STUNNED"; uiAi.className = "safe";
                stunTimer -= dt;
                
                // Gravity check
                if(neighbor.position.y > 0) neighbor.position.y -= 0.1;

                if(stunTimer <= 0) {
                    // Get up
                    neighbor.rotation.x = 0;
                    neighbor.position.y = 0;
                    aiState = "CHASE"; // He's mad now
                }
            } else {
                // Vision
                const nEye = neighbor.position.clone().add(new THREE.Vector3(0,12,0));
                const toP = camera.position.clone().sub(nEye);
                const dist = toP.length();
                let see = false;
                if(dist < 80) {
                    const nd = new THREE.Vector3(); neighbor.getWorldDirection(nd);
                    if(nd.dot(toP.normalize()) > 0.4) {
                        // Raycast check walls
                        const ray = new THREE.Raycaster(nEye, toP.normalize(), 0, 80);
                        const hits = ray.intersectObjects(walls);
                        if(hits.length===0 || hits[0].distance > dist) see = true;
                    }
                }

                if(see) {
                    aiState = "CHASE";
                    uiAi.innerText = "CHASING"; uiAi.className = "danger";
                    neighbor.lookAt(camera.position.x, 0, camera.position.z);
                    neighbor.translateZ(0.65);
                    
                    if(dist < 5) {
                        notify("CAUGHT!", "red");
                        setTimeout(()=>location.reload(), 1000);
                    }
                } else {
                    // Patrol / Lost
                    if(aiState === "CHASE" && dist > 100) aiState = "PATROL";
                    
                    if(aiState === "PATROL") {
                        uiAi.innerText = "PATROL"; uiAi.className = "safe";
                        const wp = waypoints[wpIdx];
                        neighbor.lookAt(wp.x, 0, wp.z);
                        if(neighbor.position.distanceTo(wp) < 2) wpIdx = (wpIdx+1)%waypoints.length;
                        else neighbor.translateZ(0.35);
                    }
                }
                
                // Walk Anim
                const t = performance.now()*0.01;
                lLeg.rotation.x = Math.sin(t); rLeg.rotation.x = -Math.sin(t);
            }

            renderer.render(scene, camera);
        }
        animate();

        window.onresize=()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)};
    </script>
</body>
</html>